<?php	
/**
 * Arquivo SQLParser.class.php
 * 
 * @author Luciano
 * @copyright 2007 Neoconn Networks
 * @license http://baze.saulovallory.com/license
 * @version SVN: $Id$
 * @since 0.9
 * @package Baze.classes.data
 */
import( 'system.Collection' );
import( 'system.data.TrackField' );
import( 'system.data.IDbDriver' );
import( 'system.data.MySQLDriver' );
import( 'system.data.PgSQLDriver' );
import( 'system.data.MSSQLDriver' );

/**
 * Classe SQLParser<br />
 * This class receives a command SQL and transforms the
 * properties of the fields that will be generated by the query (not NonQuery)
 * in objects.  Each identified field is generated an object with the properties
 * of this field and kept in a Collection object. The class does not make total validation
 * of query. The same one must be valid and linear (string).
 *
 * @author Luciano
 * @copyright 2007 Neoconn Networks
 * @license http://baze.saulovallory.com/license
 * @version SVN: $Id$
 * @since 0.9
 * @package Baze.classes.data
 */
class SQLParser
{
	//Por enquanto SQLParser somente trabalha com consultas SQL
	private $SQL_ACTIONS = array( 'select'); //, 'create', 'delete', 'drop', 'insert', 'alter', 'show', 'use');

	private $SQL_HWORDS	= array( 'by', 'from', 'into', 'where', 'in', 'inner', 'join', 'left',  'right', 'on', 'group', 'order', 'top', 'ties', 'with');
	private $SQL_TYPES	= array( 'int', 'string', 'blob');
	private $SQL_FUNCS	= array( 'all', 'count', 'distinct', 'limit', 'now', 'sum', 'avg', 'count');
	private $SQL_OPER	= array( '=', '!=', '+', '-', '*', '/', '<', '>', 'and', 'or');
	private $SQL_CONSTS	= array( 'asc', 'desc');
	private $SQL_XCHAR	= array( '(', ')', '%', '^', '!', '[', ']');
	private $SQL_DIV	= array( ' ', "\t", "\n", "\c", "\r");

	private $commandText;			//string
	private $arrayFields;			//array
	private $arrayTables;			//array
	private $arraySQL;				//array
	private $dbDriver;				//string of driver used
	private $conn;
	private $dbms;					//Vocabulary of diferents database type
	private $columnsCollection;		//Collection Object of Column
	private $numFields;				//int

	/**
	 * Function __construct<br>
	 * This is the constructor method of the class.
	 *
	 * @param string $dbms - type of the database used for the connection.
	 * @param link $conn - link of the connection in use.
	 **/
	function __construct ($dbms,$conn)
	{
		if (!null && !empty($dbms))
		{
			$dbms = strtolower($dbms);

			switch ($dbms)
			{
				case 'mysql':
				case 'mysqli':
					$this->dbms = "MySQL";
					break;

				case 'pgsql':
				case 'postgree':
				case 'postgres':
				case 'postgresql':
						$this->dbms = "PgSQL";
						break;

				case 'mssql':
				case 'sqlserver':
						$this->dbms= "MSSQL";
						break;

				default:
					trigger_error ("ERROR: Not compatible DataBaze in ConnectionString parameter.\nPlease use MYSQLI, POSTGRES or MSSQL DataBaze", E_USER_ERROR);
			}//fecha Switch

			$nameDriver = $this->dbms."Driver";
			$this->dbDriver = new $nameDriver();

			$this->dbms = $dbms;
			$this->conn = $conn;
			$this->columnsCollection = new Collection();
			$this->arrayFields = array();
			$this->arraySQL = array();
			$this->arrayTables = array();
		}
	}

	/**
	 * Function adjustArrayFields()<br>
	 * This function adjusts the array fields if the command SQL gotten have a character '*'.
	 *
	 * Note: If this command contain a search with this caracter, the function 'getAllFieldQuery'
	 * is running returning an array with all the fields contained in the result.
	 *
	 * @return string - command text adjusted
	 */
	private function adjustArrayFields()
	{
		if ((count($this->arrayFields)==1) && $this->arrayFields[0] == '*')
		{
			$arrayField = $this->getAllFieldQuery();

			if ($arrayField != null)
			{ $this->arrayFields = $arrayField; }
			else
			{ trigger_error ("ERROR:Command SQL is wrong.",E_USER_ERROR); }
		}
	}

	/**
	 * Function defineArrayFields()<br>
	 * This function searchs all the fields of command SQL contained after the 'Select' clause.
	 *
	 * @return void
	 */
	private function defineArrayFields()
	{
		$j = count($this->arraySQL);

		$arrayFields = array();
		$index = 0;
		$field = "";

		for ($i=1; $i<$j; $i++)
		{
			if (in_array(strtolower($this->arraySQL[$i]),$this->SQL_HWORDS))
			{ break 1; }

			$field.= $this->arraySQL[$i];

			if ($field{strlen($field)-1} === ',')
			{
				$arrayFields[$index] = $field;
				$index++;
				$field="";
			}

			elseif (in_array(strtolower($this->arraySQL[$i+1]),$this->SQL_HWORDS))
			{
				$arrayFields[$index] = $field;
				$index++;
				$field="";
			}
			else
			{ $field.= " "; }
		}
		$this->arrayFields = $arrayFields;
		$this->adjustArrayFields();
		$this->numFields = count($this->arrayFields);
		$this->defineColumnsCollection();
	}

	/**
	 * <b>Function defineColumnsCollection() </b><br>
	 * This function adds the TrackFields objects in the columns collection of the class.
	 *
	 * @return boolean true or false
	 */
	private function defineColumnsCollection()
	{
		$count = $this->numFields;
		if ( is_array($this->arrayFields) && $count>0)
		{
			for ($i=0; $i<$count; $i++)
			{
				$obj = new TrackField($this->arrayFields[$i]);
				$this->columnsCollection->add($obj);
			}
		}
		return false;
	}

	/**
	 * <b>Function defineArraySQL()</b><br>
	 * This function breaks the command SQL and stores each word gotten in an array.
	 * With this procedure improves the parse of SQL command.
	 *
	 * @return void
	 */
	private function defineArraySQL()
	{
		$j = strlen($this->commandText);
		$part = "";
		$arrayParts = array();
		$index = 0;
		$constant = 1;

		for ($i=0; $i<$j; $i++)
		{
			$c = $this->commandText{$i};

			if (ord($c)>=0 && ord($c)<=31)
			{ $c=" "; }

			if (($c === '"' || $c === "'"))
			{ $constant = $constant * -1; }

			if (in_array($c,$this->SQL_DIV) && $constant>0)
			{
				if (!empty($part))
				{
					$arrayParts[$index] = $part;
					$index++;
					$part="";
				}
			}
			elseif ($c === ',' && $constant>0)
			{
				$part.=$c;

				if (!empty($part))
				{
					$arrayParts[$index] = $part;
					$index++;
					$part="";
				}
			}
			elseif ((in_array($c,$this->SQL_OPER) || in_array($c,$this->SQL_XCHAR)) && $constant>0)
			{
				if (empty ($part))
				{
					$arrayParts[$index] = $c;
					$index++;
				}
				else
				{
					$arrayParts[$index] = $part;
					$index++;
					$arrayParts[$index] = $c;
					$index++;
					$part="";
				}
			}
			else { $part.=$c; }
		}

		if (!empty($part))
		{ $arrayParts[$index] = $part; }

		if ($constant<0)
		{
			trigger_error ("Error: probably your SQL command contains errors<br />".$this->commandText);
			exit;
		}
		$this->arraySQL = $arrayParts;
		//echo "\nSQL:\n";
		//print_r ($this->arraySQL);
	}

	/**
	 * <b>Function defineArrayTables()</b></br>
	 * This function searchs by array SQL the used tables names in the query.
	 *
	 * @return void
	 **/
	private function defineArrayTables()
	{
		$j = count($this->arraySQL);

		$arrayWords = array();
		$index = 0;

		for ($i=0; $i<$j; $i++)
		{
			$lowerWord = strtolower($this->arraySQL[$i]);

			//Se hó uma subconsulta
			if ($lowerWord == "select")
			{
				//Avançar ao próximo campo
				$i++;

				//Obter o lower-case do campo atual
				$lowerWord = strtolower($this->arraySQL[$i]);

				//Caminhar até o final da subconsulta ou quando os campos acabarem
				while ($lowerWord!="from" && $i<$j)
				{
					//Apontar para o próximo
					$i++;

					//Obter o lower-case do campo apontado
					$lowerWord = strtolower($this->arraySQL[$i]);
				}
				if ($lowerWord=="from")
				{ $i++; }
			}
			//Se há condições a serem verificadas
			if ($lowerWord == "where")
			{
				//Avançar ao próximo campo
				$i++;

				//Obter o lower-case do campo atual
				$lowerWord = strtolower($this->arraySQL[$i]);

				while (!in_array($lowerWord,$this->SQL_HWORDS) && $i<$j)
				{
					//Obter o lower-case do campo apontado
					$lowerWord = strtolower($this->arraySQL[$i]);

					//Apontar para o próximo
					$i++;
				}
			}

			if (!empty ($this->arraySQL[$i]))
			{
				$arrayWords[$index] = $this->arraySQL[$i];
				$index++;
			}
		}

		$count = count($arrayWords);
		$arrayTableNames = array();
		$arrayTableAlias = array();
		$arrayTableCalculate = array();
		$index = 0;

		//caminhar campo a campo o array de possíveis nomes das tabelas
		for ($i=0; $i<$count; $i++)
		{
			$name="";
			$alias="";
			$calculate = false;
			$break = false;
			$len = strlen($arrayWords[$i]);

			if ($arrayWords[$i]{$len-1} === ',')
			{
				$break = true;
				$arrayWords[$i] = substr($arrayWords[$i],0,$len-1);
			}

			//se o campo atual tiver um texto válido para um nome de tabela
			if ($this->isValidTableName($arrayWords[$i]) && (!in_array($arrayWords[$i],$arrayTableNames)) && (!in_array($arrayWords[$i],$arrayTableAlias)))
			{
				//se o campo já possuir uma quebra de argumento (vírgula)
				if ($break)
				{
					$name = $arrayWords[$i];
					$alias= null;
					$calculate = false;
				}
				elseif ($count == 1)
				{
					$name = $arrayWords[$i];
					$alias = null;
					$calculate = false;
				}
				//- se o campo seguinte é um "AS"
				elseif (strtolower($arrayWords[$i+1]) == "as")
				{
					//- campo após o "AS" é o texto "ALIAS" do campo antes que o "AS".
					//- guardar informações [NOME TABELA] [APELIDO]
					$name = $arrayWords[$i];
					$alias= $arrayWords[$i+2];
					$calculate = false;
					$i = $i+2;
				}

				//- se o campo seguinte não for uma palavra reservada:
				elseif(!$this->isReserved($arrayWords[$i+1]))
				{
					//- campo seguinte do atual possui texto "ALIAS" do campo antes que o "AS".
					//- guardar informações [NOME TABELA] [APELIDO]
					$name = $arrayWords[$i];
					$alias= $arrayWords[$i+1];
					$calculate = false;
					$i++;
				}

				//- se o campo seguinte for uma palavra reservada:
				elseif (($i+1)<$count && $this->isReserved($arrayWords[$i+1]))
				{
					//- se o campo atual for um "ALIAS" contido nos dados dos Fields
					if ($this->isTableAlias($arrayWords[$i]))
					{
						//- guardar informações [NOME TABELA=NULL] [APELIDO] [CALCULADA]
						$name=null;
						$alias=$arrayWords[$i];
						$calculate = true;
					}
					else //- se o campo atual não for um "ALIAS" contido nos dados dos Fields
					{
						//- guardar informações [NOME TABELA] [APELIDO=null]
						$name=$arrayWords[$i];
						$alias = null;
						$calculate = false;
					}
				}

				$arrayTableNames[$index] = $name;
				$arrayTableAlias[$index] = $alias;
				$arrayTableCalculate[$index] = $calculate;
				$index++;
			}
		}

		for ($i=0; $i<$index; $i++)
		{
			$table = array();
			$lenName = strlen($arrayTableNames[$i]);
			$lenAlias= strlen($arrayTableAlias[$i]);

			if ($arrayTableNames[$i]{$lenName-1} == ",")
			{
				$arrayTableNames[$i] = substr($arrayTableNames[$i],0,$lenName-1);
			}

			if ($arrayTableAlias[$i]{$lenAlias-1} === ",")
			{
				$arrayTableAlias[$i] = substr($arrayTableAlias[$i],0,$lenAlias-1);
			}

			$table["name"] = $arrayTableNames[$i];
			$table["alias"]= $arrayTableAlias[$i];
			$table["isCalculate"] = $arrayTableCalculate[$i];

			$this->arrayTables[$i] = $table;
		}

		//print_r ($this->arrayTables);
	}

	/**
	 * <b>Function defineTablesNames()</b><br>
	 * This function attributes the table name for its respective field.
	 * Also, the function analyzes if the field is calculated or if the field is of the constant type.
	 *
	 * @return void
	 */
	private function defineTablesNames()
	{
		$j = $this->numFields;

		for ($i=0; $i<$j; $i++)
		{
			$obj = $this->getField($i);

			$tableAlias = $obj->getTableAlias();
			$isConstant = $obj->isConstant();
			$isCalculate = $obj->isCalculate();

			if (empty($tableAlias) && (!$isConstant) && (!$isCalculate))
			{
				$tName = $this->findTableName($obj->getRealName());
				$obj->setTableName($tName);
			}
			elseif (($ind = $this->indexTableName($tableAlias))>=0)
			{
				$table = $this->arrayTables[$ind];
				$obj->setTableName($table["name"]);
				$obj->setIsCalculate($table["isCalculate"]);
			}
			elseif (($ind = $this->indexTableAlias($tableAlias))>=0)
			{
				$table = $this->arrayTables[$ind];
				$obj->setTableName($table["name"]);
				$obj->setIsCalculate($table["isCalculate"]);
			}
		}
	}

	/**
	 * Function findTableName()<br>
	 * This function returns the table name of the field sent for the parameter $fieldName.
	 *
	 * @access public
	 * @param string nameField - name of specified field
	 * @return string - of table name found or null if failure
	 */
	public function findTableName ($fieldName)
	{
		$j = count ($this->arrayTables);
		$tableName = null;
		$nameFields = array();

		for ($i=0; $i<$j; $i++)
		{
			$table = $this->arrayTables[$i];

			$arrayStats = $this->dbDriver->helpTable($table["name"],$this->conn);

			$nameFields = $arrayStats["Field_Name"];

			if (in_array($fieldName,$nameFields))
			{
				$tableName = $table["name"];
				break 1;
			}
		}
		return $tableName;
	}

	/**
	 * Function getNumFields()<br>
	 * This function returns the number of fields in command SQL.
	 * The size is returned from the number of objects contained in field collection of the class.
	 *
	 * @return int - number of existing fields in the commandText property.
	 **/
	public function getNumFields()
	{ return $this->columnsCollection->size(); }

	/**
	 * <b>Function getAllFieldQuery()</b><br>
	 * This function searchs all names of the involved fields in
	 * the consultation and returns these names through in an array.
	 *
	 * @access private
	 * @return array - fields gotten in the correct query
	 **/
	private function getAllFieldQuery()
	{
		$result = $this->dbDriver->executeQuery($this->conn,$this->commandText);
		$count = $this->dbDriver->resultFieldsCount($result);

		$arrayFields = array();

		for ($i=0; $i<$count; $i++)
		{
			$arrayFields[$i] = $this->dbDriver->getFieldName($result,$i);
		}
		return $arrayFields;
	}

	/**
	 * Function getAllTableAlias()<br>
		 * This function stores and returns all the table alias contained in arrayTable property.
	 *
	 * @return array - table alias of SQL command
	 */
	public function getAllTableAlias()
	{
		$tableAlias = array();

		$count = count ($this->arrayTables);

		for ($i=0; $i<$count; $i++)
		{
			$table = $this->arrayTables[$i];
			$tableAlias[$i] = $table["alias"];
		}
		return $tableAlias;
	}

	/**
	 * Function getAllTableNames()<br>
	 * This function stores and returns all the table names contained in arrayTable property.
	 *
	 * @return array - table names of SQL command
	 */
	public function getAllTableNames()
	{
		$tableNames = array();

		$count = count ($this->arrayTables);

		for ($i=0; $i<$count; $i++)
		{
			$table = $this->arrayTables[$i];
			$tableNames[$i] = $table["name"];
		}
		return $tableNames;
	}

	/**
	 * Function getField()<br>
	 * This function returns the TrackField object specified from $index parameter.
	 *
	 * @param int $index
	 * @return TrackedField Object
	 *         or null if $index parameter is not numeric
	 */
	public function getField($index)
	{
		if ( is_numeric($index) && $this->numFields>0)
		{ return $this->columnsCollection->getByPosition($index); }

		return null;
	}

	/**
	 * Function getSqlCommand()<br>
	 *
	 * @return string of $commandText property
	 */
	public function getSqlCommand ()
	{ return $this->commandText; }

	/**
	 * Function indexTableName()<br>
	 * This function returns the table index using the name in the search.
	 *
	 * @param string $name - string to be used in the search
	 * @return int - a index of table search or -1 if $name not found
	 */
	public function indexTableName($name)
	{
		if (!empty($this->arrayTables))
		{
			$count = count ($this->arrayTables);

			for ($i=0; $i<$count; $i++)
			{
				$table = $this->arrayTables[$i];

				if ($table["name"] == $name)
				{ return $i; }
			}
		}
		return -1;
	}

	/**
	 * Function indexTableAlias()<br>
	 * This function returns the table index using the alias in the search.
	 *
	 * @param string $alias - string to be used in the search
	 * @return int - a index of table search or -1 if $alias not found
	 */
	public function indexTableAlias($alias)
	{
		if (!empty($this->arrayTables))
		{
			$count = count ($this->arrayTables);

			for ($i=0; $i<$count; $i++)
			{
				$table = $this->arrayTables[$i];

				if ($table["alias"] == $alias)
				{ return $i; }
			}
		}
		return -1;
	}

	/**
	 * Function isFieldName()<br>
	 * This function verifies if the parameter $text is a field name.
	 *
	 * @param string $text - text to know if the name already was used
	 * @return boolean true or false
	 */
	public function isFieldName($text)
	{
		$isName = false;
		for ($i=0; $i<$this->numFields; $i++)
		{
			$obj = $this->getField($i);

			if (strtolower($text) == strtolower($obj->getRealName()))
			{
				$isName = true;
				break 1;
			}
		}
		return $isName;
	}

	/**
	 * Function isReserved()<br>
	 * This function analyze the $word parameter to know if its value belongs the reserved words
	 *
	 * @param string $word - text with string to be analyzed
	 * @return boolean - true if $word is a reserved word or false if not
	 */
	public function isReserved($word)
	{
		//lower-case text
		$lowerWord = strtolower($word);

		//flag for reserved word
		$flag = false;

		if (in_array($lowerWord,$this->SQL_ACTIONS))
		{ $flag = true; }

		if (in_array($lowerWord,$this->SQL_CONSTS))
		{ $flag = true; }

		if (in_array($lowerWord,$this->SQL_DIV))
		{ $flag = true; }

		if (in_array($lowerWord,$this->SQL_FUNCS))
		{ $flag = true; }

		if (in_array($lowerWord,$this->SQL_HWORDS))
		{ $flag = true; }

		if (in_array($lowerWord,$this->SQL_OPER))
		{ $flag = true; }

		if (in_array($lowerWord,$this->SQL_TYPES))
		{ $flag = true; }

		if (in_array($lowerWord,$this->SQL_XCHAR))
		{ $flag = true; }

		return $flag;
	}

	/**
	 * Function isTableAlias()<br>
	 * This function verifies if the parameter $text is a table alias.
	 *
	 * @param string $text - text to know if the alias already was used
	 * @return boolean true or false
	 */
	public function isTableAlias($text)
	{
		$isAlias = false;

		for ($i=0; $i<$this->numFields; $i++)
		{
			$obj = $this->getField($i);

			if (strtolower($text) == strtolower($obj->getTableAlias()))
			{
				$isAlias = true;
				break 1;
			}
		}

		return $isAlias;
	}

	/**
	 * Function isValidTableName()<br>
	 * This function verifies if a field text is valid to be a name of a table.
	 * If the text is not a reserved word, or name of a field, is not a numerical
	 * value or not have a invalid caracter, this text is valid to be a name of a table.
	 *
	 * @param string $text - text that will be analyzed as valid for table name
	 * @return boolean true or false
	 */
	public function isValidTableName ($text)
	{
		$flag = true;

		if ($this->isReserved($text))
		{ $flag = false; }

		if (substr_count($text,".")!=0)
		{ $flag = false; }

		if (substr_count($text,"'")!=0)
		{ $flag = false; }

		if (substr_count($text,'"')!=0)
		{ $flag = false; }

		if ($this->isFieldName($text))
		{ $flag = false; }

		if (is_numeric($text))
		{ $flag = false; }

		return $flag;
	}

	/**
	 * Function setSqlCommand()<br>
	 * This function attributes to SQL command in the commandText
	 * property and calls the methods to define arrays of fields,
	 * of tables and the method of definition array names.
	 *
	 * @param string $sqlCommand - text of sql command
	 * @return boolean true or false
	 */
	public function setSqlCommand ($sqlCommand)
	{
		$this->commandText = $sqlCommand;
		$this->defineArraySQL();

		if ($this->verifyAction($this->arraySQL[0]) && $this->validateSQL())// && $this->verifyFrom($sqlCommand))
		{
			$this->defineArrayFields();
			$this->defineArrayTables();
			$this->defineTablesNames();
			return true;
		}
		return false;
	}

	/**
	 * Function validateSQL()<br>
	 * This function verifies the partial validity of a SQL command.
	 * The function only validates commands of type "SELECT".
	 *
	 * @return bolean - true if is a valid SQL Command
	 *                  false if is a invalid SQL Command
	 */
	private function validateSQL()
	{
		if (strtolower($this->arraySQL[0]) != "select")
		{
			trigger_error ("Error: This Class only works with query consultations!");
			return false;
		}

		if (in_array("(",$this->arraySQL) || in_array("(",$this->arraySQL))
		{
			$arrayCount	= array_count_values($this->arraySQL);
			$numOpenPar = $arrayCount['('];
			$numClosePar= $arrayCount[')'];

			if ($numOpenPar != $numClosePar)
			{
				trigger_error ("Error: probably your SQL command contains errors");
				return false;
			}
		}

		if (!$this->validateJOIN())
		{ return false; }

		return true;
	}

	/**
	 * Function validateINNER()<br>
	 * This function verifies the validity of clause "INNER" proceeding
	 * from a command "JOIN" (generally used in data base MSSQL).
	 *
	 * @return boolean - true or false
	 */
	private function validateJOIN()
	{
		$j = count($this->arraySQL);

		for ($i=0; $i<$j; $i++)
		{
			if ((strtolower($this->arraySQL[$i])=="join"))
			{
				$type = strtolower($this->arraySQL[$i-1]);

				if ($type=="inner" || $type=="left" || $type=="right" || $type=="cross" || $type=="outer")
				{ return true; }

				trigger_error ("Error: probably your SQL command contains errors");
				return false;
			}
		}
		return true;
	}

	/**
	 * Funciton verifyAction()<br>
	 * This function verifies the action of a SQL command.
	 *
	 * @param string $sqlAction - text of sql command
	 * @return boolean true or false
	 */
	private function verifyAction ($sqlAction)
	{
		if (in_array(strtolower($sqlAction),$this->SQL_ACTIONS))
		{ return true; }

		return false;
	}
}

/*	$sql =	"SELECT All id,
		ALL p.name aS Nome,
		'sdfa ewf,efe' text,
		depto AS Departamento,
		SUM(val),
		city c
		FROM People AS p
		INNER JOIN Department ON (p.depto = Department.cod)
		WHERE p.city='RJ'";

/*$sql = 	"SELECT e.S_code, a.nHours, b.OT
		FROM
		(employee e
		inner join (select S_code, Sum(Totalhr)as nHours
		from Timesheetdetail
		group by s_code) a
		on e.S_code = a.S_code)
		left join (select S_code, Sum(Totalhr) as OT
		from Timesheetdetail
		where timecode = 2
		group by S_code) b
		on e.S_code = b.S_code";*/

/*$sql = "SELECT F.cod, F.nome as Nome, d.nomedep FROM Funcionario AS F, Departamento d WHERE Funcionario.cod = d.cod";*/

/*$sql = "SELECT all e1.name FROM emp e1,emp e2
WHERE e1.dept_no = e2.dept_no AND e2name = 'JONES'";

$o = new SQLParser("mysql");
$o->setSqlCommand($sql);
$j = $o->getNumFields();

for ($i=0; $i<$j; $i++)
{
	$obj = $o->getField($i);
	echo ("------------------\n");
	echo "$i - Alias: ".$obj->getAlias()."\n";
	echo "$i - Arguments: ".$obj->getArguments()."\n";
	echo "$i - Real Name: ".$obj->getRealName()."\n";
	echo "$i - Table Name: ".$obj->getTableName()."\n";
	echo "$i - Table Alias: ".$obj->getTableAlias()."\n";

	echo "Calculate: ";
	if ($obj->isCalculate())
	{
		echo "yes\n";
	}
	else { echo "no\n"; }

	echo "Distinct: ";
	if ($obj->isDistinct())
	{
		echo "yes\n";
	}
	else { echo "no\n"; }

	echo "All: ";
	if ($obj->isAll())
	{
		echo "yes\n";
	}
	else { echo "no\n"; }

	echo "Constant: ";
	if ($obj->isConstant())
	{
		echo "yes\n";
	}
	else { echo "no\n"; }
}*/